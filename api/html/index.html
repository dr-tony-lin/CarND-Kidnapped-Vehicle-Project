<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Unscented Kalman Filter Project: Extended Kalman Filter Project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Unscented Kalman Filter Project
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">By Tony Lin</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Extended Kalman Filter Project </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Content of the Submission and Usage</h2>
<p>This submission includes the following c++ files:</p><ul>
<li><a class="el" href="main_8cpp.html">main.cpp</a>: the main function that communicate with the simulator and drive the estimation process using UKF.</li>
<li><a class="el" href="ParticleFilter_8h.html">filter/ParticleFilter.h</a>, <a class="el" href="ParticleFilter_8cpp.html">filter/ParticleFilter.cpp</a>: contains the particle filter implementation</li>
<li><a class="el" href="helper__functions_8h.html">utils/helper_functions.h</a>: contains some helper functions</li>
<li>map/Map.h.h defines landmark map</li>
<li><a class="el" href="Partition2D_8h.html">map/Partition2D.h</a> contain an implementation of a 2D partition for speeding up finds of nearest landmarks.</li>
</ul>
<h3>Usage</h3>
<p>By default, the program will use 1000 particles. However, it can be launched with different particles and noise with: </p><pre class="fragment">./particle_filter [-parts number] [-stdgps number number number] [-stdland| number number]
</pre><p>Where the command line options are described as follows:</p>
<ul>
<li>-parts: specifies the number of particles to use</li>
<li>-stdgps: specifies the x, y, and yaw noise of GPS measurements</li>
<li>-stdland, specify the x, and y noise of landmark measurements</li>
</ul>
<p>The program will listen on port 4567 for an incoming simulator connection. Only one simulator should be connected at anytime, though the program does not prohibit it. To start a new simulator, terminate the existing one first, then start a new one.</p>
<p>To start the simulator:</p>
<h4>On Windows</h4>
<pre class="fragment">term2_sim9.exe path_to_obj_pose-laser-radar-synthetic-input.txt
</pre><h4>Other platforms:</h4>
<pre class="fragment">./term2_sim9 path_to_obj_pose-laser-radar-synthetic-input.txt
</pre><h4>Repeat simulations</h4>
<p>The program can run one simulation only, it needs to be restarted in order to restart a simulation.</p>
<h4>Build</h4>
<p>For Windows, Bash on Ubuntu on Windows should be used. Both gcc and clang can be used to build the program.</p>
<p>To build the program, invoke the following commands on the bash terminal: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;mkdir build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd build</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;cmake ..</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;make</div></div><!-- fragment --><p>The program can be built to output more information for disgnosis purpose by defining <b>VERBOSE_OUT</b> macro. In addition, the program can be built to perform sanity tests on the 2D partitioning algorithm by defining <b>TEST_PARTITION</b> macro.</p>
<h4>Build API Documentation</h4>
<p>The documentation for functions, classes and methods are included in the header files in Doxygen format. To generate Api documentation with the included doxygen.cfg:</p>
<ol type="1">
<li>Make sure doxygen is installed</li>
<li>cd to the root folder of this project</li>
<li><p class="startli">Issue the following command:</p>
<p class="startli">doxygen doxygen.cfg</p>
</li>
</ol>
<h2>The Implementation</h2>
<h3>The source code structure</h3>
<p>The src folder contains three folders for the source files: . filter: contains KalmanFilter.h, UKF.[h,cpp], and utils.[h,cpp] files which implement Unscented Kalman Filter. . performance: contains RMSEEvaluator.h which provides RMSE evaluation functionality. . sensor: contains source code for defining sensor measurement.</p>
<h5>File names</h5>
<p>In this project, I made a class to have its own .h, and .cpp files. More specifically, a class source file contains exactly one class, and has the same name as the class it contains. On the other hand,</p>
<h4>The libs folder</h4>
<p>The libs folder contains Eigen and json.hpp required by the program.</p>
<h2>KalmanFilter class</h2>
<p>This class define the baseline Kalman filter functionalities including the <b>ProcessMeasurement()</b>, <b>Predict()</b>, and <b>Update()</b> methods that need to be provided by a subclass.</p>
<p>It's data members include the state, and the state covariance matrices. Refer to the <a href="api/html/classKalmanFilter.html">API documentation</a>.</p>
<h2>UKF class</h2>
<p>This class extends KalmanFilter class and implements an Unscented Kalman Filter.</p>
<p>The API documentation for UKF can be found <a href="api/html/classUKF.html">here</a>.</p>
<h3>The Unscented Kalman Filter Process</h3>
<p>The process is implemented in method <em>ProcessMeasurement()</em>.</p>
<h3>Initialization</h3>
<p>The UKF is initialized upon receiving the first measurement.</p>
<h4>CTRV Initialization</h4>
<p>If the first measurement is from radar. The state is computed from the radar's measurement using <em>utils::RadarToCTRV()</em> function.</p>
<p>If the first measurement is from lidar, the measured position is used to populate the CTRV state: P<sub>x</sub> , P<sub>y</sub> , and &amp;#936;.</p>
<h4>State Covariance Initialization</h4>
<p>The covariance is initialized as a 5x5 identity matrix.</p>
<p>The <em>ProcessMeasurement()</em> method returns immediately after the initialized is completed.</p>
<h4>Skipping Measurements</h4>
<p>Since we can turn off either the lidar or radar measurements, the <em>ProcessMeasurement()</em> method will return immediately when a skipped measurement is received. In this case, the current state will remain the same.</p>
<h3>Prediction</h3>
<p>After initialization, a prediction is performed by <em>Predict()</em> method. It involves the following operations:</p>
<h4>Creating Sigma Points</h4>
<p>The <em>CreateSigmaPoints()</em> is called first to create 15 sigma points</p>
<h4>Predict The New CTRV State Using the Sigma Points</h4>
<p>After the sigma points are created, <em>PredictWithSigmaPoints()</em> method is invoked with the delta time to predict the current sigma points.</p>
<p>Then <em>ComputeMeanOfSigmaPoints()</em> method is invoked to compute the CTRV from the means of the predicted sigma points.</p>
<h3>Update</h3>
<p>After the prediction is completed, the <em>Update()</em> method is invoked to update the prediction with the new sensor measurements. The method performs the following operations:</p>
<h4>Predict The New Measurements using Sigma Points</h4>
<p>The same sigma points computed during the prediction stage are used to predict the new measurement. This is done by invoking the <em>PredictMeasurementFromSigmPoints()</em> method.</p>
<p>For radar measurements, the method will convert the sigma points to the radar measurement space using <em>utils::PVToRadar()</em> function. Then it computes the means of the sigma points to obtain radar measurement prediction and the measurement covariance matrix (a 3x3 matrix).</p>
<p>The <em>utils::PVToRadar()</em> function computes the bearing angle using <em>atan2(P<sub>x</sub> , P<sub>y</sub>)</em>, could we use CTRV's &amp;#936; element directly? No, we couldn't, as CTRV's &amp;#936; models the yaw angle, the direction the car is turning, namely <em>atan2(dP<sub>y</sub>, dP<sub>x</sub>)</em>. While the radar's bearing is the angle between the car and the radar, which is <em>atan2(P<sub>y</sub> , P<sub>x</sub>)</em>.</p>
<p>For lidar measurements, the method will uses the sigma points directly for the lidar measurement space, then it computes the means of the sigma points to obtain the lidar measurement prediction and the measurement covariance matrix (a 2x2 matrix).</p>
<h4>Computing The Cross Corelation Matrix, the Kalman Gain</h4>
<p>After the measurement prediction is made, the cross correlation matrix between the differences of the sigma points with respect to the predicted CTRV state and measurements is computed. Together with the measurement covariance matrix, we can compute the Kalman gain matrix.</p>
<h4>Update the CTRV State and the State Covariance Matrix</h4>
<p>Finally, the predicted CRTV state is updated using the Kalman gain, and the difference between the measurements and the predicted measurements.</p>
<p>Then, the state covariance matrix is updated using the Kalman gain matrix and the measurement covariance matrix.</p>
<h3>Angular correction for radar estimates</h3>
<p>For correct estimate of angular movements, angles, and angular differences between predictions and measurements needs to be normalized to [ &amp;#960;, -&amp;#960; ). This is also applied to the &amp;#968; element of the CRTV vector.</p>
<h3>Vectorization</h3>
<p>Could the speed of the filter be improved by vectorization? To answer this question, I have created a git branch, vectorization, that contains a more vectorized version of the filter. For example, the original code, and the vectorized version are as follows:</p>
<p><b>The original code:</b> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void UKF::PredictWithSigmaPoints(const double dt) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  Xsig_pred = MatrixXd(n_x, 2 * n_aug + 1);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  for (int i = 0; i &lt; 2 * n_aug + 1; i++) {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    VectorXd col = Xsig_aug.col(i);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    double dt2 = dt * dt / 2.0;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    double cos_psi = cos(col(3));</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    double sin_psi = sin(col(3));</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    if (fabs(col(4)) &lt; EPSLION) { // avoid division by zero</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;      double vkdt = col(2) * dt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;      Xsig_pred.col(i) &lt;&lt; col(0) + vkdt * cos_psi + dt2 * cos_psi * col(5),</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;          col(1) + vkdt * sin_psi + dt2 * sin_psi * col(5),</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;          col(2) + dt * col(5), col(3) + dt2 * col(6), col(4) + dt * col(6);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    } else {</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;      double c1 = col(2) / col(4);</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;      double delta_psi = col(4) * dt;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;      double npsi = col(3) + delta_psi;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;      Xsig_pred.col(i) &lt;&lt; col(0) + c1 * (sin(npsi) - sin_psi) +</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;                              dt2 * cos_psi * col(5),</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;          col(1) + c1 * (-cos(npsi) + cos_psi) + dt2 * sin_psi * col(5),</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;          col(2) + dt * col(5), col(3) + delta_psi + dt2 * col(6),</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;          col(4) + dt * col(6);</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    }</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  }</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;}</div></div><!-- fragment --><p><b>The vectorized version</b> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void UKF::PredictWithSigmaPoints(const double dt) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  Xsig_pred = MatrixXd(n_x, 2 * n_aug + 1);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  double dt2 = dt * dt / 2.0;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  // Vectorize matrix/vector operations</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  ArrayXd cos_psi = Xsig_aug.row(3).array().cos();</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  ArrayXd sin_psi = Xsig_aug.row(3).array().sin();</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  ArrayXd x5dt2 = Xsig_aug.row(5) * dt2; // will be 15x1!</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  ArrayXd dt2_cos = cos_psi * x5dt2;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  ArrayXd dt2_sin = sin_psi * x5dt2;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  ArrayXd delta_psi = Xsig_aug.row(4) * dt; // will be 15x1!</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  ArrayXd npsi = Xsig_aug.row(3).array() + delta_psi.transpose();</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  ArrayXd npsi_cos = cos_psi - npsi.cos();</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  ArrayXd npsi_sin = npsi.sin() - sin_psi;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  // Compute the perdiction for row 2, 3, and 4</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  Xsig_pred.row(2) = Xsig_aug.row(2).array() + Xsig_aug.row(5).array()*dt;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  Xsig_pred.row(3) = Xsig_aug.row(3).array() + Xsig_aug.row(6).array()*dt2;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  Xsig_pred.row(4) = Xsig_aug.row(4).array() + Xsig_aug.row(6).array()*dt;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  // Compute the prediction of row 0, and 1</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  for (int i = 0; i &lt; 2 * n_aug + 1; i++) {</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    VectorXd col = Xsig_aug.col(i);</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    VectorXd pred = Xsig_pred.col(i);</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    if (fabs(col(4)) &lt; EPSLION) { // Avoid divide by 0</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;      double vkdt = col(2) * dt;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;      Xsig_pred.col(i)(0) = col(0) + vkdt*cos_psi(i) + dt2_cos(i);</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;      Xsig_pred.col(i)(1) = col(1) + vkdt*sin_psi(i) + dt2_sin(i);</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    } else { </div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;      double c1 = col(2) / col(4);</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;      Xsig_pred.col(i)(0) = col(0) + c1*npsi_sin(i) + dt2_cos(i);</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;      Xsig_pred.col(i)(1) = col(1) + c1*npsi_cos(i) + dt2_sin(i);</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;      Xsig_pred.col(i)(3) += delta_psi(i); // adjust row 3</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    }</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  }</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;}</div></div><!-- fragment --><p>To build the vectorized version, the cmake file is modified to have build with -mavx -msse -mfma flags.</p>
<p>Unfortunately, the result of vectorization did not improve the performance, it actually caused 8-10% of performance drop! This has been observed with Bash on Windows (g++), and Mac (AppleClang).</p>
<p>It is still unclear to me why vectorization does not improve the performance. The possible reasons could include:</p>
<ol type="1">
<li>The data is not large enough to take the advantage of vectorization.</li>
<li>Extra data preparation required for the vectorization might have degraded the performance.</li>
</ol>
<h2>RMSEEvaluator class</h2>
<p>The RMSE evaluation implemented in the starter code is not efficient as it keeps all past measurements and estimates in a list, and evaluate RMSE for every new measurement on the entire list.</p>
<p>The purpose of this class is to implement a more efficient RMSE mechanism that does not need to store past measurements and estimates. It maintains current sum of the square errors, and total number of past estimates. RMSE for a new estimate can be simply obtained by taking the square root of the mean of square error.</p>
<h2>EKF class</h2>
<p>It implements an Extended Kalman Filter refactored from the Extended Kalman Filter project. This is used for comparison purposes.</p>
<h2>Result</h2>
<p>The RMSE performance of the Unscented Kalman filter is optimized when the acceleration deviation is at 0.5 and the yaw acceleration deviation is at 0.65. The following table shows the RMSE for running dataset 1 only, dataset 2 only, and dataset 1 followed by dataset 2:</p>
<table class="doxtable">
<tr>
<th align="center"></th><th align="center">Dataset 1</th><th align="center">Dataset 2</th><th align="center">Dataset 1, 2  </th></tr>
<tr>
<td align="center">X </td><td align="center">0.0639 </td><td align="center">0.0629 </td><td align="center">0.0634 </td></tr>
<tr>
<td align="center">Y </td><td align="center">0.0858 </td><td align="center">0.0582 </td><td align="center">0.0733 </td></tr>
<tr>
<td align="center">Vx </td><td align="center">0.2288 </td><td align="center">0.3004 </td><td align="center">0.2670 </td></tr>
<tr>
<td align="center">Vy </td><td align="center">0.2963 </td><td align="center">0.2797 </td><td align="center">0.2882 </td></tr>
</table>
<p>The execution of the third scenario is recorded in <a href="video1.mp4">this video</a>.</p>
<h3>Effects of Acceleration Noise</h3>
<p>The following table shows how the X, and Y RMSE of the Unscented Kalman filter varies with the process noise: the acceleration noise, and the yaw acceleration noise.</p>
<table class="doxtable">
<tr>
<th align="center"></th><th align="center">0.05 </th><th align="center">0.5 </th><th align="center">0.65 </th><th align="center">1 </th><th align="center">2 </th><th align="center">4 </th><th align="center">Std YawDD  </th></tr>
<tr>
<td align="center">**0.05** </td><td align="center">0.2147, 0.2222</td><td align="center">0.1069, 0.142 </td><td align="center">0.107, 0.1423</td><td align="center">0.1073, 0.1429</td><td align="center">0.1076, 0.1437</td><td align="center">0.1071, 0.1438</td><td align="center"></td></tr>
<tr>
<td align="center">**0.4** </td><td align="center">0.2036, 0.1954</td><td align="center">0.0631, 0.0743</td><td align="center">0.0626, 0.0744</td><td align="center">0.0623, 0.0751</td><td align="center">0.0627, 0.0769</td><td align="center">0.0627, 0.0769</td><td align="center"></td></tr>
<tr>
<td align="center">**0.5** </td><td align="center">0.2047, 0.1983</td><td align="center">0.0640, 0.0733</td><td align="center">**0.0634, 0.0733**</td><td align="center">0.0631, 0.0739</td><td align="center">0.0634, 0.757 </td><td align="center">0.0640, 0.0778</td><td align="center"></td></tr>
<tr>
<td align="center">**0.6** </td><td align="center">0.2058, 0.2010</td><td align="center">0.065, 0.0729</td><td align="center">0.0643, 0.0729</td><td align="center">0.0640, 0.0735</td><td align="center">0.0642, 0.0752</td><td align="center">0.081, 0.0904</td><td align="center"></td></tr>
<tr>
<td align="center">**8** </td><td align="center">0.2215, 0.2316</td><td align="center">0.0811, 0.0865</td><td align="center">0.0808, 0.0862</td><td align="center">0.0814, 0.0872</td><td align="center">0.0821, 0.0893</td><td align="center">0.0832, 0.0929</td><td align="center"></td></tr>
<tr>
<td align="center">**16** </td><td align="center">0.2263, 0.2318</td><td align="center">0.0833, 0.0898</td><td align="center">0.083, 0.0896</td><td align="center">0.0834, 0.0903</td><td align="center">0.0851, 0.0933</td><td align="center">0.0872, 0.098</td><td align="center"></td></tr>
<tr>
<td align="center">**Std A**</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
</table>
<p>It shows that the best RMSE performance is ontained when the acceleration deviation is around 0.5, and the yaw acceleration deviation is around 0.65.</p>
<h3>Normalized Innovation Squared (NIS) Evaluation</h3>
<p>The NIS results is shown in the following table:</p>
<table class="doxtable">
<tr>
<th align="center">Std A, Std Yawdd </th><th align="center">NIS Chart  </th></tr>
<tr>
<td align="center">0.05, 0.05 </td><td align="center"><a href="./nis-005-005.png">Chart</a> </td></tr>
<tr>
<td align="center">0.1, 0.1 </td><td align="center"><a href="./nis-01-01.png">Chart</a> </td></tr>
<tr>
<td align="center">0.5, 0.65 </td><td align="center"><a href="./nis-05-065.png">Chart</a> </td></tr>
<tr>
<td align="center">8, 2 </td><td align="center"><a href="./nis-8-2.png">Chart</a> </td></tr>
<tr>
<td align="center">16, 6 </td><td align="center"><a href="./nis-16-6.png">Chart</a> </td></tr>
</table>
<p>The charts show when the noise level is reduced, NIS moves up and the variances also goes up, and when the noise level is increased, the NIS moves down.</p>
<h3>Comparison With Extended Kalman Filter</h3>
<p>My experiments shows that Unscented Kalman filters out-performs Extended Kalman filters. This can be seen from the following table:</p>
<table class="doxtable">
<tr>
<th align="center"></th><th align="center">EKF </th><th align="center">improved  </th></tr>
<tr>
<td align="center">X </td><td align="center">0.0817 </td><td align="center">+22% </td></tr>
<tr>
<td align="center">Y </td><td align="center">0.0852 </td><td align="center">+14% </td></tr>
<tr>
<td align="center">Vx </td><td align="center">0.3773 </td><td align="center">+29% </td></tr>
<tr>
<td align="center">Vy </td><td align="center">0.4254 </td><td align="center">+32% </td></tr>
</table>
<h4>Sensors and Performance</h4>
<p>The following table compares the X, and Y RMSE against different combinations of sensors. The <b>UKF performs best with both lidar and radar sensors</b>. On the other hand, the Unscented Kalman filter performs poorly with only one sensor.</p>
<table class="doxtable">
<tr>
<th align="center"></th><th align="center">Std A=0.5, Std YawDD=0.65  </th></tr>
<tr>
<td align="center">Radar and Lidar </td><td align="center">0.0642, 0.0736 </td></tr>
<tr>
<td align="center">Radar only </td><td align="center">0.198, 0.233 </td></tr>
<tr>
<td align="center">Lidar only </td><td align="center">0.351 0.357 </td></tr>
</table>
<h2>Catch Run Away Car</h2>
<p>I made the catch run away car project to use the UKF implemented in this project. The program can be invoke with:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./catch_run</div></div><!-- fragment --><p>A video recorded during the catch is <a href="./catch-run-away-car.mp4">here</a>. As can be seen from the video, the cars are close enough, but could not get close enough. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
